# Unity3D的C/S架构消息通讯模板
在Unity3D中使用的Socket消息通讯模板，服务器也是Csharp写的。

客户端作为Unity3D项目的一部分，导入到Unity3D工程中，使用某个脚本的`Update()`方法进行驱动;  

服务器是一个单独的控制台程序，需要写一个`Main`方法。

### 网络消息MsgXXX

本通讯模型通过一种叫做 **“消息协议”** 的对象进行通讯。

消息协议通过继承自类`MsgBase`来定义，本质上是一个具有特定功能的结构。

消息协议的基类：`MsgBase`类，完成了对所有协议的一些通用操作，编码解码之类的操作，不要修改。

这些消息协议对象中应该包含有此消息协议应有的一些信息，比如登录协议`MsgLogin`就应该至少包含`userid`和`pwd`两个字段（成员变量）。

实际上，继承自MsgBase后的自定义消息协议类，看起来就像是C++里的结构体一样，只有构造函数和数个公有成员变量。

### 自定义新的协议

写新的自定义协议时，只需要且必须继承自`MsgBase`后在构造函数中为`protoName`属性赋值为此协议的类名的字符串。

写新的自定义协议时，请保证服务端和客户端都添加了一模一样的新的自定义协议的类声明。

服务端需要同时在类`MsgHandler`中添加与此协议同名的静态方法，用于处理在收到此协议时所要做的事情。

客户端只需要使用`NetManager.AddMsgListener()`方法，来动态地监听某一消息的到来并进行对应的处理。

详细方式请分别参考目录**Server**和**Client**中的`README.md`文件。

##### 为什么服务端中消息协议的类型名，消息协议的protoName变量的值，和收到此消息时的处理方法需要同名？

`MsgHandler`中用来处理收到某消息时的静态方法，会在服务器收到并解析一条消息协议时，通过Csharp的反射机制，使用此收到的消息协议中的成员变量`protoName`来找到对应的处理方法。

哦对了，客户端虽然不需要写同名的静态回调方法，但是protoName变量也应该是同名的，这个服务端和客户端没差。（简单来说就是对消息协议的类定义应该双端相同）
